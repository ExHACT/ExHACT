
// ================================================================================================
// FILE DESCRIPTION
// This file contains some outlines for the ChainComplex trait, and its associated objects, functions, etc.
//
// FILE HISTORY
// 20201119: created by Greg Henselman-Petrusek
// 20201119-present: edited by Greg Henselman-Petrusek and Haibin Hang
// ================================================================================================

// ------------------------------------------------------------------------------------------------
// OVERVIEW OF CONTENTS
// ------------------------------------------------------------------------------------------------

// This file describes the basic api for working with (filtered) chain complexes.  **The API is specifically designed to be comaptible with BASIS MATCHING COMPLEXES**.  In particular, there are ways to work with and/or specify
//      - the levels of the "long" and "short" filtrations
//      - the sublattice of Sub:=(the lattice of subspaces under meet=intersection and join=sum) generated by the levels of the filtrations
//      - quotients of form N/D, where N and D are elements of Sub; such quotients are called *subquotients* of the complex.  We write SubQuo for the set of all such subquotients.
//      - maps between subquotients of the complex
//          - these include inclusion maps, quotient maps, and boundary maps)
//          - they do not include chain maps between complexes; those will be designed in a different API
//      - bases for the spaces in SubQuo
//      - matrix representations of maps between spaces in SubQuo
// Theoretically, a chain complex object should be able to keep track of all these things.

// -----------------------------------------------------------------------------------------------
// SCRATCHWORK
// -----------------------------------------------------------------------------------------------

// CHX

// CHX : SHOULD SPECIFY WHETHER YOU WANT ROW OR COLUMN MAJOR

// SUBQUOTIENTS SHOULD HAVE 2 FILTRATIN PARAMETERS AND 1 DEGREE PARAMETER

// BASIS <-> BASIS INDEX SET <-> MATRIX INDEX SET <-> MATRIX

// SUBQUOID <-> (VECSPACEID, SUBSPACESPEC) // SUBSPACE SPEC IS A LATTICE ELEMENT

// VECSPACE ID <-> UUID

// SHOULD THERE BE BASED + UNBASED MAP SPECS????


// -----------------------------------------------------------------------------------------------
// DISCUSSION: SHOULD ANY OF THESE THINGS BE A MATRIX?
// -----------------------------------------------------------------------------------------------


// FILTRATION INFORMATION
// ------------------------
// In principle, a filtration on a chain complex can be expressed by a function f: B -> R, where B is a carefully chose bases, R is the real numers, and f is a function that specifies when each basis vector is born.  One could naturally think of f as a vector with real coefficients, and you could get one such vector for the space of chains in each dimension: f0, f1, ..., fN.  It would be natural to think of such a collection of vectors as a matrix.
// However, I'm not convinced that this is a useful way to look at things.  What would you ever do with that matrix?


// ------------------------------------------------------------------------------------------------
// FILTRATION PARAMETERS
// ------------------------------------------------------------------------------------------------


/// This struct records a filtration parameter for a subspace.  The idea is that
/// FParam{bot: True} < FParam{param: s} < FParam{param: t} <  FParam{top: True}
/// for all s < t.
///
/// # Attributes
///
/// * `top` - If true, then the struct represents the whole space
/// * `bot` - If true, then the struct represents the zero space
/// * `param` - A numerical filtration parameter
///

/*
struct FParam{
    top: bool,
    bot: bool,
    param: Option<number>
}
*/

enum ExtendedLine<T>{
    top,
    bot,
    realnum(T)
}

enum ExtendedLineTwice<T>{
    lower(ExtendedLine<T>),
    upper(ExtendedLine<T>),
}

/// Given a filtration of chain complexes F_0(C) \subset ... \subset F_N(C), this struct represents one of subscripts on F.
///
/// # Attributes
///
/// * `FParam` - A birth time
///
/*
struct FParam_native{
    fparam: FParam
}
*/
/// Let d denote the boundary operator for the top-level complex F_N(C)
///     B_n,t = d(F_t(C_n+1)) // space of n-boundaries at time t
///     Z_n,t = {c \in F_N(C_n) : dc \in F_t(C_n-1)} // inverse image of (C_{n-1} at time t)
/// We call B_n,* the "pushed" filtration and Z_n,* the "pulled" filtration.  We can combine these into a single filrtation
///     B_n,0 < ... < B_n,T < Z_n,0 < ... < Z_n,T
/// This struct is used to specify a level of this "combined" filration.  It does this by specifying (i) a subscript (ie FParam), and (ii) a bool to indicate whether the subscript goes on a B_n,* or a Z_n,*.
///
/// # Attributes
///
/// * `FParam` - The filtration parameter of the n+1 chains or the n-1 chains
/// * `pulled` - If True, then `param` refers to the pulled filtration; otherwise it refers to the pushed filtration.
///

// enum FiltKind{
//     native,
//     pushed,
//     pulled
// }
//
// struct FParam{
//     fkind: FiltKind,
//     fparam: Param
// }

/*
struct FParam_puxxed{
    fparam: FParam,
    pulled: bool
}
*/
// -----------------------------------------------------------------------------------------------
// SUBSPACES:
//      FILTRATION LEVELS
//      INTERSECTIONS OF FILTRAITON LEVELS
//      SUMS OF INTERSECTIONS OF FILTRATION LEVELS
// AND SUBQUOTIENTS:
//      N/D, WHERE N AND D ARE SUBSPACE
// -----------------------------------------------------------------------------------------------


/// This struct records an intersection of two subspaces:
///     (i)  a "native" filtration level (ie, n-chains born by time t)
/// and
///     (ii) an "inherited" of "puxxed" filtration level: EITHER
///         (a) a "pushed" filtration level, ie d((n+1)-chains born by time s), OR
///         (b) a "pulled" filtraiton level, ie d^{-1}((n-1)-chains born by time s)
/// We call a subspace that can be expressed in this way a "basic subspace".  The set of all basic subspaces has a natural partial order, namely the product order on the set {all pairs of form (native filtration level, inherited filtration level)}.
///
/// # Attributes
///
/// * `chaindeg` - If None, then we use chains of all degrees.  Otherwise we use only use chains of pure degree `deg`
/// * `native` - Parameter for the native filtration
/// * `puxxed` - Parameter for the inherited filtration
///
/// # Examples
///
/// ```
/// // kernel of the boundary d2 matrix at time t = 0.5
/// fChCx_Subspace_Basic{
///     chaindeg: 1
///     native: FParam_native{fparam: FParam{top:False, bot:False, param: 0.5}}},
///     puxxed: FParam_puxxed{fparam: FParam{top:False, bot:True,  param: None}, pulled: True}
/// }
/// // image of the boundary d2 matrix at time t = 0.5
/// fChCx_Subspace_Basic{
///     chaindeg: 1
///     native: FParam_native{fparam: FParam{top:True, bot:False, param: None}}},
///     puxxed: FParam_puxxed{fparam: FParam{top:False, bot:True,  param: 0.5}, pulled: False}
/// }
/// // all 1-chains born by time t = 0.5
/// fChCx_Subspace_Basic{
///     chaindeg: 1
///     native: FParam_native{fparam: FParam{top:True, bot:False, param: None}}},
///     puxxed: FParam_puxxed{fparam: FParam{top:False, bot:True,  param: 0.5}, pulled: False}
/// }
/// // all chains (of all gradings) born by time t = 0.5
/// fChCx_Subspace_Basic{
///     chaindeg: None
///     native: FParam_native{fparam: FParam{top:False, bot:False, param: 0.5}}},
///     puxxed: FParam_puxxed{fparam: FParam{top:True,  bot:False, param: None}, pulled: True}
/// }
/// ```
struct Chx_spec_basicsubspace{
    chaindeg: Option<usize>,
    native: FParam,
    puxxed: FParam
}


/// This struct represents a subquotient N/D, where both numerator N = N1 + ... + Nk and denomenator D = D1 + ... + Dl are sums of basic subspaces.  We put certain restrictions on the sets {N1, ..., Nk} and {D1, ..., Dl} to eliminate redundancey.  In particular, we require each set to be an *antichains* in the product poset {set of all tuples (native_filtration_parmeter, puxxed_filtration_parameter)}.  In practice, we drop Ni from the set if there exists an Nj such that Ni < Nj in the product order.
///
/// # Attributes
///
/// * `spaces` - An array of fChCx_Subspace_Basic's
struct Chx_spec_subquo{
    num: Vec<Chx_spec_basicsubspace>,
    den: Vec<Chx_spec_basicsubspace>
}

struct BasisID{
    uuid_space: String,
    uuid_basis: String
}


// -----------------------------------------------------------------------------------------------
// MAPS BETWEEN SUBQUOTIENTS
// -----------------------------------------------------------------------------------------------


/// A struct that specifies a map between subquotients of a filtered chain complex.  It is not associated to any specific filtered complex.  It is more like a "recipe" for getting a map.
///
/// # Attributes
///
/// * `dom` - The domain of the map.  We regard the domain as a quotient of a subspace N (numerator) by a subspace D (denomenator).
/// * `cod` - The codomain of the map.  We regard the codomain as a quotient of a subspace N (numerator) by a subspace D (denomenator).
/// * `delta_chaindeg` - The grade of the map, that is, degree(f(x)) - degree(x)
/// * `splittingbasis` - (If applicable) specifies the basis that defines the split map.
///
/// # Examples
///
/// ```
/// // The split map from homology (in dimension 1, at time 0.5) to the space of 1-chains at time 0.7, given by the basis with uuid U123RT32.
/// map_spec    =   Chx_spec_map{
///     dom: Chx_spec_subquo{
///         num: [
///         Chx_spec_basicsubspace{
///             chaindeg: 1,
///             native: FParam_native{
///                 fparam: FParam{ top: False, bot: False, param: 0.5  }
///             },
///             puxxed: FParam_puxxed{
///                 fparam: FParam{ top: False, bot: True,  param: None },
///                 pulled: False
///             }
///         }
///         ],
///         den: [
///         Chx_spec_basicsubspace{
///             chaindeg: 1,
///             native: FParam_native{
///                 fparam: FParam{ top: True,  bot: False, param: None }
///             },
///             puxxed: FParam_puxxed{
///                 fparam: FParam{ top: False, bot: False, param: 0.5  },
///                 pulled: False
///             }
///         }
///         ]
///     },
///     cod: Chx_spec_subquo{
///         num: [
///         Chx_spec_basicsubspace{
///             chaindeg: 1,
///             native: FParam_native{
///                 fparam: FParam{ top: False, bot: False, param: 0.7  }
///             },
///             puxxed: FParam_puxxed{
///                 fparam: FParam{ top: False, bot: True,  param: None },
///                 pulled: False
///             }
///         }
///         ],
///         den: [
///         Chx_spec_basicsubspace{
///             chaindeg: 1,
///             native: FParam_native{
///                 fparam: FParam{ top: False, bot: True,  param: None }
///             },
///             puxxed: FParam_puxxed{
///                 fparam: FParam{ top: False, bot: True,  param: None },
///                 pulled: False
///             }
///         }
///         ]
///     },
///     delta_chaindeg: 0,
///     splittingbasis: U123RT32
/// }
/// ```
struct Chx_spec_map{
    dom: Chx_spec_subquo,
    cod: Chx_spec_subquo,
    delta_chaindeg: usize,
    splittingbasis: Option<BasisID>
}

// -----------------------------------------------------------------------------------------------
// THE CHAIN COMPLEX TRAIT:
//      GENERATING MATRICES
//      OBTAINING "STANDARD" BASIS ID'S
//      OBTAINING FILTRATION VALUES
// -----------------------------------------------------------------------------------------------


enum MajorDimension{
    row,
    col
}

enum ChxTransformKind{
    identity,
    boundary
}

/// A trait that summarizes everything we want to do with a filtered chain complex
pub trait ChainComplex<>{
    /// Returns a matrix
    ///
    /// # Arguments
    ///
    /// * `map_spec` - An array [s_1, s_2, ..., s_n], where each s_k is a Chx_spec_map encoding a function f_k.  Taken together, this sequence of structs represents a composition of functions f_1 * ... * f_k
    /// * `matrix_spec` - Possible values:
    ///         dense,
    ///         CSR,
    ///         impl:MatrixRowOracle
    /// * `index_row` - Possible values: usize, simplex
    /// * `index_col` - Possible values: usize, simplex
    /// * `type_snz` - The type of the matrix entries (integer, rational, finite field)
    /// * `basisid_row` - The basis that indexes the rows of the matrix
    /// * `basisid_col` - The basis that indexes the columns of the matrix
    ///
    /// # Returns
    ///
    /// * A matrix representing the linear map specified by `map_spec`, with respect to the given bases `basisid_row` and `basisid_col`.
    ///
    /// # Examples
    ///
    /// ```
    /// matrix = ChainComplex.matrix{
    ///     [map_spec],                 // a (length 1) seqeunce of map specifiers
    ///     ExhactMatrixOracle_simplex  // a matrix type
    ///     Simplex,                    // simplices will index the rows
    ///     Simplex,                    // simplices will index the columns
    ///     F2                          // Galois field (order 2) coefficients
    ///     XT673RT5                    // uuid for the codomain basis
    ///     YT98YN2B                    // uuid for the domain basis
    // }
    /// ```

    fn SmoPort<T: impl SmoPort>(
        &self,
        major_dim       :   MajorDimension, // row or column
        transform       :   ChxTransformKind,
        basisindexspec_row: ChxSubquoBasisBijectionSpec<Filt1, Filt2>,
        basisindexspec_col: ChxSubquoBasisBijectionSpec<Filt1, Filt2>
    ) -> SmoPort<MajKey_outer, MajKey_inner, MinKey_outer, MinKey_inner, SnzVal>;

    /// Returns the basisID of the standard basis in degree `chaindeg`.  If `chaindeg` is None, then returns a basisID for the total complex.
    fn standard_basisID(chaindeg: Option<usize>) -> BasisID;

    /// Returns the basisID of a basis that the user has previously assigned an human-readable name.
    fn basisid( &self, chaindeg: Option<chaindeg>, name: String ) -> BasisID;

    /// Return the filtration values of the elements of a given basis.  It is assume that this basis is indexed by some function X: I -> basis; this function is specified via spec_basisindex.  The output format (array, iterable, hashmap, etc.) is determined by `outputformat`.
    fn filtration<T>( &self, spec_basisindex: BasisIndexSpec, outputformat: String) -> T;

    /// Returns the dimension of the space of chasins in degree `chaindegree`.  If `chaindegree` is None, then returns the sum of degrees in all dimensions.  This function may return a None value if the dimensions of one or more chain spaces have not been computed (e.g., if we have not yet counted all the simplices of a simplicial complex)
    fn rank( &self, chaindegree: Option<usize>) -> Option<usize>;

    /// Returns the linear dimension of the specified subquotient.  This function may return a None value if the rank is unkown.
    fn rank( &self, subquo: Chx_spec_subquo) -> Option<usize>;
}
